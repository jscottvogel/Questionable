{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst proxyHost = '127.0.0.1';\nconst proxyPort = 3500;\n\n// Proxy URL\nconst proxyUrl = `http://${proxyHost}:${proxyPort}`;\nconst initialState = [];\nconst eventsSlice = createSlice({\n  name: 'events',\n  initialState: {\n    events: initialState\n  },\n  reducers: {\n    loadEvents: (state, action) => {\n      // check to see if there are any new events\n      // if so, add them to the state\n      // if not, do nothing\n      if (state.events.length === 0) {\n        state.events = action.payload;\n      } else {\n        let temp = state.events.filter(event => event.id !== action.payload.id);\n        if (temp.length !== state.events.length) {\n          state.events = action.payload;\n        }\n      }\n    },\n    addEvent: (state, action) => {\n      state.events.push(action.payload);\n    },\n    deleteEvent: (state, action) => {\n      const eventId = action.payload;\n      state.events = state.events.filter(event => event.id !== eventId);\n    },\n    updateEvent: (state, action) => {\n      const {\n        id,\n        title,\n        description,\n        date,\n        time\n      } = action.payload;\n      const existingEvent = state.events.find(event => event.id === id);\n      if (existingEvent) {\n        existingEvent.title = title;\n        existingEvent.description = description;\n        existingEvent.date = date;\n        existingEvent.time = time;\n      }\n    }\n  }\n});\n\n// Write a function that has `dispatch` and `getState` as arguments\nconst fetchEvents = (dispatch, getState) => {\n  // Make an async HTTP request\n  return fetch('http://127.0.0.1:3500/events', {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    cache: \"no-cache\" // *default, no-cache, reload, force-cache, only-if-cached\n  }).then(res => {\n    console.log(res);\n    const evts = res.json();\n    console.log(evts);\n    return evts;\n  }).then(evts => {\n    dispatch({\n      type: \"events/loadEvents\",\n      payload: evts\n    });\n  }).catch(err => console.log(err));\n  // todo, error condition\n};\n\nfunction removeEvent(id, dispatch) {\n  //console.log( \"deleteEvent: \" + id );\n  return fetch(`http://127.0.0.1:3500/events/${id}`, {\n    method: \"DELETE\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    cache: \"no-cache\" // *default, no-cache, reload, force-cache, only-if-cached\n  }).then(response => {\n    if (response.ok) {\n      dispatch({\n        type: \"events/deleteEvent\",\n        payload: id\n      });\n    } else {\n      console.log(response);\n      console.log(\"Event not deleted\");\n    }\n  }).catch(error => {\n    console.log(error);\n  });\n}\nexport const {\n  loadEvents,\n  addEvent,\n  deleteEvent,\n  updateEvent\n} = eventsSlice.actions;\nexport { fetchEvents, removeEvent };\nexport default eventsSlice.reducer;","map":{"version":3,"names":["createSlice","proxyHost","proxyPort","proxyUrl","initialState","eventsSlice","name","events","reducers","loadEvents","state","action","length","payload","temp","filter","event","id","addEvent","push","deleteEvent","eventId","updateEvent","title","description","date","time","existingEvent","find","fetchEvents","dispatch","getState","fetch","method","headers","cache","then","res","console","log","evts","json","type","catch","err","removeEvent","response","ok","error","actions","reducer"],"sources":["/home/fred/Questionable/questionable-client/src/features/events/eventsSlice.js"],"sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\n\nconst proxyHost = '127.0.0.1';\nconst proxyPort = 3500;\n\n// Proxy URL\nconst proxyUrl = `http://${ proxyHost }:${ proxyPort }`;\n\nconst initialState = [];\n\nconst eventsSlice = createSlice( {\n    name: 'events',\n    initialState: {\n        events: initialState\n    },\n    reducers: {\n        loadEvents: ( state, action ) => {\n            // check to see if there are any new events\n            // if so, add them to the state\n            // if not, do nothing\n            if ( state.events.length === 0 ) {\n                state.events = action.payload;\n            } else {\n                let temp = state.events.filter( event => event.id !== action.payload.id );\n                if ( temp.length !== state.events.length ) {\n                    state.events = action.payload;\n                }\n            }\n        },\n        addEvent: ( state, action ) => {\n            state.events.push( action.payload );\n        },\n        deleteEvent: ( state, action ) => {\n            const eventId = action.payload;\n            state.events = state.events.filter( event => event.id !== eventId );\n        },\n        updateEvent: ( state, action ) => {\n            const { id, title, description, date, time } = action.payload;\n            const existingEvent = state.events.find( event => event.id === id );\n            if ( existingEvent ) {\n                existingEvent.title = title;\n                existingEvent.description = description;\n                existingEvent.date = date;\n                existingEvent.time = time;\n            }\n        }\n    }\n} );\n\n// Write a function that has `dispatch` and `getState` as arguments\nconst fetchEvents = ( dispatch, getState ) => {\n    // Make an async HTTP request\n    return fetch( 'http://127.0.0.1:3500/events', {\n        method: \"GET\",\n        headers: { \"Content-Type\": \"application/json\" },\n        cache: \"no-cache\" // *default, no-cache, reload, force-cache, only-if-cached\n    } ).then( res => {\n        console.log( res );\n        const evts = res.json();\n        console.log( evts );\n        return evts;\n    } ).then( evts => {\n        dispatch( { type: \"events/loadEvents\", payload: evts } );\n    } ).catch( err => console.log( err ) );\n    // todo, error condition\n\n}\n\nfunction removeEvent( id, dispatch ) {\n    //console.log( \"deleteEvent: \" + id );\n    return fetch( `http://127.0.0.1:3500/events/${ id }`, {\n        method: \"DELETE\",\n        headers: { \"Content-Type\": \"application/json\" },\n        cache: \"no-cache\" // *default, no-cache, reload, force-cache, only-if-cached\n    } )\n        .then( response => {\n            if ( response.ok ) {\n                dispatch( { type: \"events/deleteEvent\", payload: id } );\n            } else {\n                console.log( response );\n                console.log( \"Event not deleted\" );\n            }\n        } )\n        .catch( error => {\n            console.log( error );\n        } );\n}\n\nexport const { loadEvents, addEvent, deleteEvent, updateEvent } = eventsSlice.actions;\n\nexport { fetchEvents, removeEvent };\n\nexport default eventsSlice.reducer;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}